# シェルソートは、挿入ソートを改良したアルゴリズムです。挿入ソートが整列済みのデータ列に強いことを利用しています。

# シェルソートでは、データ列において一定の間隔 h だけ離れた要素たちからなる部分列を対象とした挿入ソートを、
# h を小さくしながら (間隔を狭めながら) 繰り返してソートを行っていきます。h は適当に大きな値から始め、段階的に小さくしていき、
# 最終的に 1 にします。h が 1 のとき、間隔が 1 離れた要素たちからなる部分列というのは元のデータ列そのものですから、
# このとき単純な挿入ソートを行うことになります。この時点でデータ列は既にほとんど整列済みとなっていることが期待されるため、ここで挿入ソートの強みが活かされます。

# シェルソートの計算量は間隔列 H に強く依存します。シェルソートの計算量解析を正確に行うことは難しく、未解決です。
# いくつかの有名な間隔列に対しては計算量解析が行われており、例えば h_i = 3h_{i+1} + 1を満たす整数列 (..., 364, 121, 40, 13, 4, 1) を
# 間隔列として採用した際のシェルソートは、平均計算量が O(n^{1.25}) になることが知られています。

# では、要素数 n の数列を昇順にソートするシェルソートのプログラムを、上の疑似コードに従って実装してください。
# 数列 h_1, ... , h_k が入力として与えられるので、それを間隔列として採用してください。なお、この数列は上で示した漸化式h_i = 3h_{i+1} + 1を満たしています。

# https://paiza.jp/works/mondai/sort_efficient/sort_efficient__shell

def insertion_sort(a, n, h)
    for i in h...n
        # a[i] を、整列済みの a[i-ah], ..., a[i-2h], a[i-h] の適切な位置に挿入する

        # 実装の都合上、a[i] の値が上書きされてしまうことがあるので、予め a[i] の値をコピーしておく
        x = a[i]

        # a[i] の適切な挿入位置を表す変数 j を用意
        j = i-h

        # a[i] の適切な挿入位置が見つかるまで、a[i] より大きい要素を後ろにずらしていく
        while j >= 0 && a[j] > x
            a[j+h] = a[j]
            j -= h
        end

        # a[i] を挿入
        a[j+h] = x
    end
end

n = gets.to_i
a = gets.split(" ").map(&:to_i)
k = gets.to_i
h = gets.split(" ").map(&:to_i)

# shell_sort(a : 配列, n : aの要素数, h : 間隔列)
h.each do |h_value|
    insertion_sort(a, n, h_value)
end

puts a.join(" ")