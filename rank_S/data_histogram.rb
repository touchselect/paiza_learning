# 情報の通信を行う上で、圧縮は必要不可欠な技術です。 生のデータをそのまま通信に用いると非常に多くの時間がかかる場合でも、
# そのデータの特徴を活かした適切な圧縮を行うことによりデータサイズを大幅に削減し、高速に通信を行うことができます。


# 例えば次のような特徴を持ったデータを考えます。


# ・データは文字列で表され、文字数は最大で 2^60 と非常に長い文字列の可能性があります。
# ・データに含まれる文字は英小文字('a' - 'z') の26種類のみからなります。
# ・データには規則性があり、同様の文字列の繰り返しの組み合わせで表現可能です。

# このような特徴を活かした圧縮方法はいろいろ考えられますが、ここでは次のような書式に従う圧縮方法を考えてみます。


# 2(2u2lt4d)3(rb)pa
# これは繰り返し回数を数字によって表現した書式です。 数字(文字列) という書式は文字列を数字の回数だけ繰り返すことを表します。
# ただし、数字が1 のときは数字は省略され、丸括弧の中の文字列の長さが1のときは丸括弧も省略されます。 上記の例はこのルールに従って書かれています。


# この例を展開すると次の文字列になります。


# uulltdddduulltddddrbrbrbpa
# さて、この程度の大きさのデータであれば展開した文字列もそれほど大きくはなりませんが、例えば次のような圧縮後のデータを考えてみます。


# 10000(10000(10000(2000(ab)500(dz)c200h)2mu3000(fpr)))
# このデータを展開すると文字列の長さは5,201,900,300,000,000文字になります。


# また、圧縮されたデータは必ずしも最適に圧縮されているとは限りません。
# 例えば、uuuuuu は圧縮後の文字列が最短という意味において6u が最適な圧縮ですが、
# 2(3u)、3(2u)、3u3u、4uuu、uuuuuu などのように最適でない圧縮が行われている場合もあります。


# 上記書式に従った圧縮後のデータが与えられるので、そのデータを展開して得られる圧縮前の文字列に対して、
# 'a' - 'z' の文字がそれぞれ何文字出現しているかを求めるプログラムを作成してください。ただし、与えられる圧縮後のデータの長さは1000文字を超えません。
# また、圧縮前の文字列の長さは2^60 (= 1,152,921,504,606,846,976) 文字を超えません。
def count_digits(num)
    num.to_s.length
end
code = gets.chomp
code_a = code.split("")
base = code.scan(/\d+/).map(&:to_i)
base_count = 0
digit = 0
a_z_count = {}
("a".."z").each do |s|
    a_z_count[s] = 0
end
key = 1
keys= []
mono = false

code_a.each.with_index do |char, i|
    if ("0".."9").include?(char)
        digit += 1
        if digit == count_digits(base[base_count])
            key *= base[base_count]
            keys.push(base[base_count])
            digit = 0
            base_count += 1
            if ("a".."z").include?(code_a[i + 1])
                mono = true
            end
        end
    elsif ("a".."z").include?(char)
        a_z_count[char] += key
        if mono
            key /= keys.pop
            mono = false
        end
    elsif char == ")"
        key /= keys.pop
    end
end

a_z_count.each do |ans|
    puts ans.join(" ")
end